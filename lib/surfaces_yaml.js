// Generated by CoffeeScript 1.7.1
(function() {
  var Aliases, Descript, Regions, Surfaces, clone, entry, extend, util;

  util = require('./util');

  clone = util.clone;

  extend = util.extend;

  entry = util.entry;

  Descript = (function() {
    function Descript(descript) {
      this.descript = descript;
    }

    Descript.prototype.get = function() {
      return this.descript;
    };

    Descript.prototype.to_string = function() {
      var key, str, value, _ref;
      str = "descript\r\n";
      str += "{\r\n";
      _ref = this.descript;
      for (key in _ref) {
        value = _ref[key];
        str += key + ' : ' + value + '\r\n';
      }
      return str += "}\r\n";
    };

    return Descript;

  })();

  Regions = (function() {
    function Regions(regions) {
      this.regions = regions;
    }

    Regions.prototype.get = function() {
      return this.regions;
    };

    Regions.prototype.to_string = function() {
      var character, characters, entry_mousedown, entry_mouseup, entry_tooltip, region, region_name, setting, str, _i, _len, _ref, _ref1, _ref2;
      characters = {};
      entry_mouseup = {};
      entry_mousedown = {};
      entry_tooltip = {};
      _ref = this.regions;
      for (region_name in _ref) {
        region = _ref[region_name];
        _ref1 = region.characters;
        for (character in _ref1) {
          setting = _ref1[character];
          characters[character] = true;
          if (setting.tooltip != null) {
            if (entry_tooltip[character] == null) {
              entry_tooltip[character] = [];
            }
            entry_tooltip[character].push("" + region.is + "," + setting.tooltip);
          }
          if (setting.cursor != null) {
            if (setting.cursor.mouseup != null) {
              if (entry_mouseup[character] == null) {
                entry_mouseup[character] = new entry('mouseup');
              }
              entry_mouseup[character].add(region.is, setting.cursor.mouseup);
            }
            if (setting.cursor.mousedown != null) {
              if (entry_mousedown[character] == null) {
                entry_mousedown[character] = new entry('mousedown');
              }
              entry_mousedown[character].add(region.is, setting.cursor.mousedown);
            }
          }
        }
      }
      str = '';
      for (character in characters) {
        str += "" + character + ".cursor\r\n";
        str += "{\r\n";
        if (entry_mouseup[character] != null) {
          str += entry_mouseup[character].to_string();
        }
        if (entry_mousedown[character] != null) {
          str += entry_mousedown[character].to_string();
        }
        str += "}\r\n";
        str += "" + character + ".tooltips\n";
        str += "{\r\n";
        if (entry_tooltip[character] != null) {
          _ref2 = entry_tooltip[character];
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            entry = _ref2[_i];
            str += entry + "\r\n";
          }
        }
        str += "}\r\n";
      }
      return str;
    };

    return Regions;

  })();

  Surfaces = (function() {
    function Surfaces(surfaces) {
      var id, surface, _ref;
      this.surfaces = surfaces;
      this.surfaces_finalized = {};
      _ref = this.surfaces;
      for (id in _ref) {
        surface = _ref[id];
        this.finalize_surface(id);
      }
    }

    Surfaces.prototype.get = function() {
      return this.surfaces_finalized;
    };

    Surfaces.prototype.finalize_surface = function(id) {
      var base, e, surface, _i, _len, _ref;
      if (this.surfaces_finalized[id] != null) {
        return;
      }
      surface = clone(this.surfaces[id]);
      if (surface.base != null) {
        if (!(surface.base instanceof Array)) {
          surface.base = [surface.base];
        }
        _ref = surface.base;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          base = _ref[_i];
          if (this.surfaces[base] != null) {
            this.finalize_surface(base);
            extend(surface, this.surfaces_finalized[base]);
          } else {
            throw "surface's base entry not found in surface " + id;
          }
        }
      }
      this.surfaces_finalized[id] = surface;
      try {

      } catch (_error) {
        e = _error;
        console.log(e);
        return exit;
      }
    };

    Surfaces.prototype.validate = function(surface) {};

    Surfaces.prototype.to_string = function(regions) {
      var id, str, surface, _ref;
      str = '';
      _ref = this.surfaces_finalized;
      for (id in _ref) {
        surface = _ref[id];
        if (surface.is != null) {
          str += this.to_string_surface(surface, regions);
        }
      }
      return str;
    };

    Surfaces.prototype.to_string_surface = function(surface, regions_definition) {
      var str;
      str = "surface" + surface.is + "\r\n";
      str += "{\r\n";
      if (surface.points != null) {
        str += this.to_string_from_entries(this.to_string_surface_points(surface.points, 'point'));
      }
      if (surface.balloons != null) {
        str += this.to_string_from_entries(this.to_string_surface_balloons(surface.balloons));
      }
      if (surface.elements != null) {
        str += this.to_string_from_entries(this.to_string_surface_elements(surface.elements));
      }
      if (surface.animations != null) {
        str += this.to_string_from_entries(this.to_string_surface_animations(surface.animations, regions_definition));
      }
      if (surface.regions != null) {
        str += this.to_string_from_entries(this.to_string_surface_regions(surface.regions, regions_definition));
      }
      str += "}\r\n";
      return str;
    };

    Surfaces.prototype.to_string_from_entries = function(entries) {
      var str, _i, _len;
      str = '';
      for (_i = 0, _len = entries.length; _i < _len; _i++) {
        entry = entries[_i];
        str += entry + "\r\n";
      }
      return str;
    };

    Surfaces.prototype.to_string_surface_points = function(points, name) {
      var child, child_name, result;
      result = [];
      if (points instanceof Object) {
        for (child_name in points) {
          child = points[child_name];
          result = result.concat(this.to_string_surface_points(child, name + '.' + child_name));
        }
      } else {
        result.push(name + ',' + points);
      }
      return result;
    };

    Surfaces.prototype.to_string_surface_balloons = function(balloons) {
      var entry_2, name, name_2, result;
      result = [];
      for (name in balloons) {
        entry = balloons[name];
        if (entry instanceof Object) {
          for (name_2 in entry) {
            entry_2 = entry[name_2];
            result.push(name + '.balloon.' + name_2 + ',' + entry_2);
          }
        } else {
          result.push('balloon.' + name + ',' + entry);
        }
      }
      return result;
    };

    Surfaces.prototype.to_string_surface_elements = function(elements) {
      var element, id, order, result, _i, _len;
      order = [];
      for (id in elements) {
        element = elements[id];
        if (element.is != null) {
          order[element.is] = id;
        }
      }
      result = [];
      for (_i = 0, _len = order.length; _i < _len; _i++) {
        id = order[_i];
        if (!(id != null)) {
          continue;
        }
        element = elements[id];
        result.push("element" + element.is + "," + element.type + "," + element.file + "," + element.x + "," + element.y);
      }
      return result;
    };

    Surfaces.prototype.to_string_surface_animations = function(animations, regions_definition) {
      var animation, id, index, option, options, order, pattern, region_entries, region_entry, result, surface, wait, x, y, _i, _j, _k, _len, _len1, _len2, _ref;
      order = [];
      for (id in animations) {
        animation = animations[id];
        if (animation.is != null) {
          order[animation.is] = id;
        }
      }
      result = [];
      for (_i = 0, _len = order.length; _i < _len; _i++) {
        id = order[_i];
        if (!(id != null)) {
          continue;
        }
        animation = animations[id];
        if (animation.interval != null) {
          result.push("animation" + animation.is + ".interval," + animation.interval);
        }
        if (animation.option != null) {
          result.push("animation" + animation.is + ".option," + animation.option);
        }
        if (animation.patterns != null) {
          _ref = animation.patterns;
          for (index = _j = 0, _len1 = _ref.length; _j < _len1; index = ++_j) {
            pattern = _ref[index];
            if (pattern.surface != null) {
              pattern.surface;
              if (isNaN(pattern.surface)) {
                if ((this.surfaces_finalized[pattern.surface] != null) && (this.surfaces_finalized[pattern.surface].is != null)) {
                  surface = this.surfaces_finalized[pattern.surface].is;
                } else {
                  throw "non-number animation surface target not found : " + id + " -> " + pattern.surface;
                }
              } else {
                surface = pattern.surface;
              }
            }
            if (pattern.wait != null) {
              wait = pattern.wait;
            }
            if (pattern.x != null) {
              x = pattern.x;
            }
            if (pattern.y != null) {
              y = pattern.y;
            }
            options = (function() {
              var _k, _len2, _ref1, _results;
              _ref1 = [surface, wait, x, y];
              _results = [];
              for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
                option = _ref1[_k];
                if (option != null) {
                  _results.push("," + option);
                }
              }
              return _results;
            })();
            result.push(("animation" + animation.is + ".pattern" + index + "," + pattern.type) + options.join(''));
          }
        }
        if (animation.regions != null) {
          region_entries = this.to_string_surface_regions(animation.regions, regions_definition);
          for (_k = 0, _len2 = region_entries.length; _k < _len2; _k++) {
            region_entry = region_entries[_k];
            result.push("animation" + animation.is + "." + region_entry);
          }
        }
      }
      return result;
    };

    Surfaces.prototype.to_string_surface_regions = function(regions, regions_definition) {
      var c_id, coordinate, id, order, region, result, _i, _len;
      order = [];
      for (id in regions) {
        region = regions[id];
        if (region.is != null) {
          order[region.is] = id;
        }
      }
      result = [];
      for (_i = 0, _len = order.length; _i < _len; _i++) {
        id = order[_i];
        if (!(id != null)) {
          continue;
        }
        region = regions[id];
        if ((regions_definition[id] != null) && (regions_definition[id].is != null)) {
          c_id = regions_definition[id].is;
        } else {
          throw "region(collision) id not found : " + id;
        }
        if ((region.type == null) || (region.type === 'rect')) {
          result.push("collision" + region.is + "," + region.left + "," + region.top + "," + region.right + "," + region.bottom + "," + c_id);
        } else if (region.type === 'ellipse') {
          result.push("collisionex" + region.is + "," + c_id + "," + region.type + "," + region.left + "," + region.top + "," + region.right + "," + region.bottom);
        } else if (region.type === 'polygon') {
          result.push(("collisionex" + region.is + "," + c_id + "," + region.type) + ((function() {
            var _j, _len1, _ref, _results;
            _ref = region.coordinates;
            _results = [];
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              coordinate = _ref[_j];
              _results.push("," + coordinate.x + "," + coordinate.y);
            }
            return _results;
          })()).join(''));
        } else {
          throw "unknown region(collision) type : " + region.type;
        }
      }
      return result;
    };

    return Surfaces;

  })();

  Aliases = (function() {
    function Aliases(aliases) {
      this.aliases = aliases;
    }

    Aliases.prototype.get = function() {
      return this.aliases;
    };

    Aliases.prototype.to_string = function(surfaces) {
      var aliases, character, character_aliases, entries, id, is_valid, str, surface, target_id, target_ids, targets, _i, _j, _len, _len1, _ref, _ref1;
      character_aliases = {};
      for (id in surfaces) {
        surface = surfaces[id];
        if ((surface.is != null) && (surface.characters != null)) {
          _ref = surface.characters;
          for (character in _ref) {
            is_valid = _ref[character];
            if (is_valid) {
              if (character_aliases[character] == null) {
                character_aliases[character] = [];
              }
              character_aliases[character].push(id + ',' + '[' + surface.is + ']');
            }
          }
        }
      }
      _ref1 = this.aliases;
      for (character in _ref1) {
        aliases = _ref1[character];
        for (id in aliases) {
          target_ids = aliases[id];
          targets = [];
          for (_i = 0, _len = target_ids.length; _i < _len; _i++) {
            target_id = target_ids[_i];
            if (isNaN(target_id)) {
              if ((surfaces[target_id] != null) && (surfaces[target_id].is != null)) {
                targets.push(surfaces[target_id].is);
              } else {
                throw "non-number alias target not found : " + id + " -> " + target_id;
              }
            } else {
              targets.push(target_id);
            }
          }
          if (character_aliases[character] == null) {
            character_aliases[character] = [];
          }
          character_aliases[character].push(id + ',' + '[' + targets.join(',') + ']');
        }
      }
      str = '';
      for (character in character_aliases) {
        entries = character_aliases[character];
        str += "" + character + ".surface.alias\r\n";
        str += "{\r\n";
        for (_j = 0, _len1 = entries.length; _j < _len1; _j++) {
          entry = entries[_j];
          str += entry + "\r\n";
        }
        str += "}\r\n";
      }
      return str;
    };

    return Aliases;

  })();

  exports.Descript = Descript;

  exports.Regions = Regions;

  exports.Surfaces = Surfaces;

  exports.Aliases = Aliases;

}).call(this);
